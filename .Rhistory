1 + 1
1 + 2 + 3
3 * 7 * 2
4 / 2
4 / 3
#Parenthesis, Exponents, Multiplication,Division, Addition and Subtraction (PEMDAS).
hese follow the basic order of operations: Parenthesis, Exponents, Multiplication,
Division, Addition and Subtraction (PEMDAS). This means operations inside parentheses
4
4 * 6 + 5
(4 * 6) + 5
4 *(6 + 5)
#good to put white spaces before the the operators
#Variables
#A variable can take on any available data type
#The valid assignment operators are <- and =, with the first being preferred
x <- 2
x
y = 5
y
#Arrow can also point in the other Direction
3 -> z
z
#Assigning multiple Variables simultaneously
a <- b <- 7
a
b
#Using the Assign Fuction
assign("j", 4)
j
#Removing a Variable
k <- 4
k
rm(k)
#now it is gone
k
#Variable names are case sensitive
theVariable <- 17
theVariable
THEVARIABLE
#DATATYPES IN R
#Numeric, Character(string), Date/POSIXct(timebased) and logical(TRUE/FALSE)
#CLASS FUNCTION USED TO CHECK TYPE OF DATA
class(x)
#Numeric Datatype
#This is similar to a float or double in other languages.
#to check whether a variable is umeric , use is.numeric(x)
is.numeric(x)
#INTEGER , SET WITH AN L on a variable (to specify whole numbers only) and its less frequently used
i <- 5L
i
is.integer(i)
is,numeric(i)
is.numeric(i)
#INTEGER AND NUMERIC CALCULATIONS
#R nicely promotes integers to numeric when needed. This is obvious when
multiplying an integer by a numeric, but importantly it works when dividing an
integer by another integer, resulting in a decimal number
clas(4L)
class(4L)
class(2.8)
4L * 2.8
class(4L * 2.8)
class(5L)
class(2L)
5L / 2L
class(5L / 2L)
#CHARACTER DATA:  R has two primary ways of handling character data: character and factor which are handled differently
x <- "data"
x
y <- factor("data")
y
#LENGTH OF CHATACTERS we use nchar function
nchar(x)
nchar("hello")
nchar(3)
nchar(452)
#nchar doesnt work for factor data
nchar(y)
#DATES
# R has numerous different types of dates. The most useful are Date and POSIXct.Date stores just a date while POSIXct stores a date and time. Both objects are actually represented as the number of days (Date) or seconds (POSIXct) since January 1, 1970
date1 <- as.Date("2012-06-28")
date1
class(date1)
#changing the Date to numeric
as.numeric(date1)
#POSIXT
date2 <- as.POSIXct("2012-06-28 17:42")
date2
#POSIXct to numeric
as.numeric(date2)
#LUBRIDICATE AND CHRON PACKAGES  used for Easier manipulation of date and time objects
#Using functions such as as.numeric or as.Date does not merely change the formatting of an object but actually changes the underlying type
class(date1)
class(as.numeric(date1))
#LOGICAL DATATYPE
#Logicals are a way of representing data that can be either TRUEor FALSE.
TRUE * 5
FALSE * 5
#TRUE Is 1 and FALSE is 0
#can be tested is is.logical
k <- TRUE
class(k)
is.logical(k)
#T and F are shortcuts for TRUE and FALSE
TRUE
T
class(T)
T <- 7
T
class(T)
#Comparison using Logicals
2 < 3
#is two less tahn or equal to 3
2 <= 3
#is 2 greater than or equal to three
2 >= 3
#is data equal to stats
"data" < "stats"
#VECTORS : A collection of elements of the same type .c(1, 3, 2,1, 5)is a vector consisting of the numbers 1,3,2,1,5, in that order. R is a vectorized language.
#Vectors do not have a dimension, meaning there is no such thing as a column vector or row vector. These vectors are not like the mathematical vector, where there is a difference between row and column orientatin
#C(combine) used to make a vector: The most common way to create a vector is with c. The “c” stands for combinebecause multiple elements are being combined into a vector.
X <- c(1,2,3,4,5,6,7,8,9,10)
X
#Multiplying each element of the vector by 3
X * 3
#No loops are required
X + 2
X - 3
X / 4
X ^ 2
sqrt(X)
# A shortcut is the : operator, which generates a sequence of consecutive numbers, in either direction
1:10
10:1
-2:3
5:-7
#CREATING TWO VECTORS OF EQUAL LENGTH
X <- 1:10
Y <- -5:4
#add them
X + Y
#subtract them
X - Y
#MULTIPLY THEM
X * Y
#Divide them
X/ Y
# raise one to the power of the other
X ^ Y
# check the length of each
length(x)
length(y)
length(X)
length(Y)
# the length of them added together should be the same
length(X + Y)
#RECYCLING OF THE SHORTER VECTOR
#Things get a little more complicated when operating on two vectors of unequallength. The shorter vector gets recycled—that is, its elements are repeated, in order,
until they have been matched up with every element of the longer vector. If the longer one is not a multiple of the shorter one, a warning is given.
X + c(1,2)
X + c(1,2,3)
X <= 5
#that was comparison done in vector form
X > Y
X < Y
#All function to check whether the resul is true
X <- 10:1
Y <- -4:5
any(X < Y)
all(X < Y)
#any and all can be used
#The nchar function also acts on each element of a vector.
q <- c("Hockey", "Football", "Baseball", "Curling" "Rugby", + "Lacrosse", "Basketball", "Tennis","Cricket", "Soccer")
q <- c("Hockey", "Football", "Baseball", "Curling","Rugby", + "Lacrosse", "Basketball", "Tennis","Cricket", "Soccer")
q <- c("Hockey", "Football", "Baseball", "Curling","Rugby","Lacrosse", "Basketball", "Tennis","Cricket", "Soccer")
nchar(q)
nchar(Y)
#SQUARE BRACKETS USED TO ACCES INDIVIDUAL ELEMENTS OF A VECTOR([])
# The first element of x is retrieved by typing x[1] ,the first two elements by x[1:2] and nonconsecutive elements by x[c(1, 4)].
X[1]
X[1:2]
X[c(1,4)]
#Giving names to vectors:It is possible to give names to a vector either during creation or after the fact.
#NAME-VALUE PAIR TYPE OF NAMING
c(One="a", Two="y", Last="r")
# create a vector
w <- 1:3
#name the elements
names(w) <- c("a", "b", "c")
w
#FACTOR VECTORS
#Example of a  factor  vector  of text data
q2 <- c[q, "Hockey","Lacrosse", "Hockey", "Water Polo","Hockey", "Lacrosse"]
q2 <- c[q, "Hockey","Lacrosse", "Hockey", "Water Polo","Hockey", "Lacrosse"]
q2 <- c(q, "Hockey","Lacrosse", "Hockey", "Water Polo","Hockey", "Lacrosse")
#convertining it to a factor using as.factor
q2Factor <- as.factor(q2)
q2Factor
#Notice that after printing out every element of q2Factor, R also prints the levels of q2Factor. The levels of a factor are the unique values of that factor variable.Technically, R is giving each unique value of a factor a unique integer, tying it back to the character representation
#This can be seen with as.numeric.
as.numeric(q2Factor)
#SETTING  SO WE GET AN ORDERED FACTOR sometimes the order matters
factor(x=c("High School", "College", "Masters", "Doctorate"), levels=c("High School", "College", "Masters", "Doctorate"), ordered=TRUE)
#Sometimes, however, it is important to understand the order of a factor, such as when coding education level Setting the ordered argument to TRUE.creates an ordered factor with the order given in the levels argument.
#CALLING FUNCTIONS
#They make code easily repeatable
#Mean Function
?mean
#getting info about a function , put a quetion mark before it
#for binary operators us same thing
?`+`
#we can use apropos function
apropos("mea")
#MISSING DATA (NULL AND NA )
#is.na used to test vectr for missingness
z <- c(1,2,NA,8,3,NA,3)
z
is.na(z)
zChar <- c("Hockey", NA, "Lacrosse")
zChar
is.na(zChar)
#mean os zChar
mean z
mean(z)
#using rm to remove the na(missing data ) then calculate the eman
mean(z, na.rm=TRUE)
#NULL is the absence of anything. It is not exactly missingness, it is nothingness.
# An important difference between NA and NULL is that NULL is atomical and cannot exist within avector. If usedinside a vector, it simply disappears.
z <- c(1, NULL,3)
z
#Even though it was entered into the vector z, it did not get stored in z. In fact, z is only two elements long.
#is.null is used to test for a null value
d <- NULL
is.null(d)
is.null(7)
#PIPES
#The pipe from the magrittr
package works by taking the value or object on the left-hand side of the pipe and inserting it into the first argument of the function that is on the right-hand side of the pipe. A simple example example would be using a pipe to feed x to the mean function
library(magrittr)
x <- 1:10
mean(x)
x %>% mean
#The result is the same but they are written differently. Pipes are most useful when used in a pipeline to chain together a series of function calls. Given a vector z that contains numbers and NAs, we want to find out how many NAs are present. Traditionally, this would be done by nesting functions.
z <- c(1, 2, NA, 8, 3, NA, 3)
sum(is.na(z))
#DOing this using pipes
z %>% is.na %>% sum
#When piping an object into a function and not setting any additional arguments, no parentheses are needed
#However, if additional arguments are used, then they should be named and included inside the parentheses after the function call. The first argument is not used, as the pipe already inserted the left-hand object into the first argument.
z %>% mean(na.rm=TRUE)
#DATA STRUCTURES
#The most common are the data.frame, matrix and list, followed by the array.
#Of these, the data.frame will be most familiar to
anyone who has used a spreadsheet, the matrix to people familiar with matrix math and
the list to programmers
#Of these, the data.frame will be most familiar to anyone who has used a spreadsheet, the matrix to people familiar with matrix math and the list to programmers
#NOTE
#In terms of how R organizes data.frames, each column is actually a vector, each of which has the same length. That is very important because it lets each column hold a different type of data (see Section 4.3). This also implies that within a column each element must be of the same type, just like with vectors.
#THE easies way is to use data.frame function
x <- 10:1
y <- -4:5
k <-  c("Hockey", "Football", "Baseball", "Curling", "Rugby","Lacrosse", "Basketball", "Tennis", "Cricket", "Soccer")
theDF <- data.frame(x,y,k)
theDF
#we can assign names to the variables during creation
theDF <- data.frame( First=x, Second=y, Sport=k)
theDF
# The most frequently checked attributes  of dataframes are the number of rows and columns using nrow and ncol
nrow(theDF)
ncol(theDF)
#dim for rows and colums as a vector
dim(theDF)
#Checking the column names of a data.frame is as simple as using the namesfunction
names(theDF)
name(theDF)[3]
names(theDF)[3]
#Checking aand Asigning rownames of  a Dataframe
rownames(theDF)
rownames(theDF)  <-c("One", "Two", "Three","Four", "Five","Six","Seven", "Eight","Nine", "Ten")
rownames(theDF)
#setting the rownames back to generic index
rownames(theDF) <- NULL
rownames(theDF)
#HEAD FUNCTION FOR FIRST FEW ROWS DISPLAY
head(theDF)
head(theDF, n=7)
#Tail function for the last few rows
tail(theDF)
#checking the type/clas of Dataframe
class(theDF)
#GETTING A PARTICULAR COLUMN
#Since each column of the data.frame is an individual vector, it can be accessed individually and each has its own class. Like many other aspects of R, there are multiple ways to access an individual column. There is the $ operator and also the square brackets. Running theDF$Sport will give the third column in theDF. That allows us to specify one particular column by name
theDF$Sport
#indexing to get more than one row
theDF(3,2)
theDF[3,2]
# row 3, columns 2 through 3
theDF[3,2:3]
# rows 3 and 5, column 2
# since only one column was selected it was returned as a vector
# hence the column names will not be printed
theDF[c(3,5),2]
# rows 3 and 5, columns 2 through 3
theDF[c(3, 5), 2:3]
# allofcolumn3
sinceitisonlyonecolumnavectorisreturned
# since it is only one column a vector is returned
theDF[, 2:3]
# allofrow2
theDF[2,]
#ACCESING COLUMNS BY NAMES
theDF[,c("First","Sport")]
#ANOTHER WAY
# just the "Sport" column
# since it is one column it returns as a (factor) vector
theDF[,"Sport"]
#the previous returned a vector
#USING CLASS RETURNS A ONE COLUMN DATAFRAME
class(theDF[, "Sport"])
# this returns a one column data.frame
theDF["Sport"]
class(theDF["Sport"])
# this also returns a (factor) vector
theDF[["Sport"]]
class(theDF[["Sport"]])
class(theDF[["Sport"]])
#USING drop=FALSE to get a single column DATAFRAME
theDF[, "Sport", drop=FALSE]
class(theDF[, "Sport", drop=FALSE])
theDF[, 3, drop=FALSE]
class(theDF[, 3, drop=FALSE])
#LISTS
Often a container is needed to hold arbitrary objects of either the same type or varying
types.Raccomplishes this through lists.
Often a container is needed to hold arbitrary objects of either the same type or varying types.Raccomplishes this through lists.
#Lists are created with the list function where each argument to the function becomes an element of the  list
# creates a three elementlist
list(1,2,3)
#creates a single element list
#the first is a three element vector
#the second element is a five element vector
(list3 <- list(c(1,2,3),3:7))
#two element list
#first element is a dataframe
#second element i a 10 element vector
list(theDF, 1:10)
#three element list
#first is a dataframe
#secod iis a vector
#third is list 3 which holds two vectors
list5 <- list(theDF, 1:10, list3)
list5
#VIEWING LIST ELEMENTS INDIVIDUALLY
names(list5)
names(list5) <- c("data.frame","vector","list")
#we gave names
names(list5)
list5
#USING NAME VALUEAIRS TO NAME ELEMENTS OF A LIST
list6 <- list(TheDataFrame=theDF, TheVector=1:10, TheList=list3)
list6
#CREATING AN EMPTY LIST OF A CERTAIN SIZE USING vector function
(emptyList <- vector(mode="List", length=4))
(emptyList <- vector(mode="list", length=4))
#USING DOUBLE SQUARE BRACKETS TO ACCESS AN ELEMENT OF A LIST
list5[[1]]
list5[["data.frame"]]
#NESTED INDEXIGN
list5[[1]]$Sport
#Onceanelement isaccesseditcanbetreatedasifthatactualelement isbeingused,allowingnestedindexingofelements.
list5[[1]][, "Second"]
list5[[1]][, "Second", drop=FALSE]
#APPENDING ELEMENTS TO ALIST
#see how long it currently is
length(list5)
#Add a fourth unnamed element
list5[[4]] <- 2
length(list5)
#addd a Fifth element, name
list5[["NewElement"]] <-  3:6
length(list5)
names(list5)
list5
#MATRICES
#very common mathematical structure that is essential to statistics is a matrix. This is similar to a data.frame in that it is rectangular with rows and columns except that every single element, regardless of column, must be the same type, most commonly all numerics. They also act similarly to vectors with element-by-element addition,multiplication, subtraction, division and equality. The nrow, ncol and dim functions work just like they do for data.frames
# create a 5x2 matrix
A <- matrix(1:10, nrow=5)
# create another 5x2 matrix
B <- matrix(21:30, nrow=5)
# create another 5x2 matrix
B <- matrix(21:40, nrow=2)
A
B
C
C <- matrix(21:40, nrow=2)
c
C
nrow(A)
nrow(x = B)
ncol(A)
dim(A)
#add them
A + B
A  * B
A %*% t(B)
#Another similarity with data.frames is that matrices can also have row and column names
colnames(A)
rownames(A)
colnames(A) <- c("Left", "Right")
rownames(A) <- c("1st", "2nd", "3rd", "4th", "5th")
colnames(B)
rownames(B)
colnames(B) <- c("First", "Second")
rownames(B) <- c("One", "Two", "Three", "Four", "Five")
colnames(C) <- LETTERS[1:10]
t(A)
#TRANSPOSING
#Notice the effect when transposing a matrix and multiplying matrices. Transposing naturally flips the row and column names. Matrix multiplication  keeps the row names from the left matrix and the column names from the right matrix
ARRAYS
#ARRAYS
#An array is essentially a multidimensional vector.It must all be of the same type, and individual elements are accessed in a similar fashion using square brackets. The first element is the row index, the second is the column index and the remaining elements arefor outer dimensions.
theArray <- array(1:12, dim=c(2, 3, 2))
theArray
#The main difference between an array and a matrix is that matrices are restricted to two dimensions, while arrays can have an arbitrary number.
source('D:/Rprojects/BasicMath/.Rhistory', encoding = 'UTF-8')
list(theDF, 1:10)
git status
